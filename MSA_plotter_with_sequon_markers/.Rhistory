family <- plink$fam
# rownames
rownames(geno) <- family$member
rownames(feno) <- feno$ID
head(feno)
# check if identitical
identical(rownames(feno), rownames(geno))
# if FALSE
ids <- intersect(rownames(feno), rownames(geno))
geno <- geno[ids, ]
feno <- feno[ids, ]
identical(rownames(feno), rownames(geno))
# load PCA data
PCA_data <- read.table("PC_ADNI.mds", header = TRUE, sep = "", stringsAsFactors = FALSE)
# add first two components to feno.qc
feno <- data.frame(feno, PCA_data[, 4:5])
# rename C1 and C2 to PC1 and PC2
names(feno)[names(feno) == "C1"] <- "PC1"
names(feno)[names(feno) == "C2"] <- "PC2"
# QC of SNPs
#    SNPs with a high rate of missing;
#    rare SNPS (e.g. having low minor allele frequency (MAF); and
#   SNPs that do not pass the HWE test.
# The function col.summary() offers different summaries (at SNP level) that can be used in QC
info.snps <- col.summary(geno)
head(info.snps)
controls <- feno$DISEASE_STATUS == 'CN'
geno.controls <- geno[controls,]
info.controls <- col.summary(geno.controls)
use <- info.snps$Call.rate > 0.95 &
info.snps$MAF > 0.05 &
abs(info.controls$z.HWE < 3.3)
mask.snps <- use & !is.na(use)
geno.qc.snps <- geno[ , mask.snps]
geno.qc.snps
annotation <- annotation[mask.snps, ]
# Number of SNPs removed for bad call rate
sum(info.snps$Call.rate < 0.95)
# Number of SNPs removed for low MAF
sum(info.snps$MAF < 0.05, na.rm=TRUE)
# Number of SNPs that do not pass HWE test
sum(abs(info.controls$z.HWE > 3.3), na.rm=TRUE)
# The total number of SNPs do not pass QC
sum(!mask.snps)
# Quality control of individuals
# The identification of individuals with discordant reported and genomic sex,
#
# the identification of individuals with outlying missing genotype or heterozygosity rate,
#
# the identification of duplicated or related individuals, and
#
# the identification of individuals of divergent ancestry from the sample.
info.indv <- row.summary(geno.qc.snps)
head(info.indv)
#--- Sex discrepancies ---
geno.X <- geno.qc.snps[,annotation$chromosome=="23" & !is.na(annotation$chromosome)]
info.X <- row.summary(geno.X)
# NOTE: Your original code had feno$gender, but the column is REPORTED_SEX
sex.discrep <- (feno$REPORTED_SEX=="Male" & info.X$Heterozygosity > 0.05) | (feno$REPORTED_SEX=="Female" & info.X$Heterozygosity < 0.25)
# Visually check
# cc <- ifelse(feno$REPORTED_SEX=="Male", "red", "blue")
# plot(info.X$Heterozygosity, col=cc)
#--- Heterozygosity ---
MAF <- col.summary(geno.qc.snps)$MAF
callmatrix <- !is.na(geno.qc.snps)
hetExp <- callmatrix %*% (2*MAF*(1-MAF))
hetObs <- with(info.indv, Heterozygosity*(ncol(geno.qc.snps))*Call.rate)
info.indv$hetF <- 1-(hetObs/hetExp)
# datatable(info.indv)
# IBD
# Transform PLINK data into GDS format
snpgdsBED2GDS("ADNI_cluster_01_forward_757LONI.bed", "ADNI_cluster_01_forward_757LONI.fam", "ADNI_cluster_01_forward_757LONI.bim",
out="GDS")
genofile <- snpgdsOpen("GDS")
#Prune SNPs for IBD analysis
set.seed(12345678)
snps.qc <- colnames(geno.qc.snps)
snp.prune <- snpgdsLDpruning(genofile, ld.threshold = 0.2,
snp.id = snps.qc)
snps.ibd <- unlist(snp.prune, use.names=FALSE)
head(snps.ibd)
# IBD analysis -- Identity By Descent
ibd <- snpgdsIBDMoM(genofile, kinship=TRUE,
snp.id = snps.ibd,
num.thread = 2)
ibd.kin <- snpgdsIBDSelection(ibd)
head(ibd.kin)
# Remove related individuals
ibd.kin.thres <- subset(ibd.kin, kinship > 0.1)
head(ibd.kin.thres)
## qc_related
ids.rel <-  SNPassoc:::related(ibd.kin.thres)
ids.rel
## qc_indiv
use <- info.indv$Call.rate > 0.9 &
abs(info.indv$hetF) < 0.20 &     # or info.inv$Heterozygosity < 0.32
!sex.discrep &
!rownames(info.indv)%in%ids.rel
mask.indiv <- use & !is.na(use)
# check if geno-qc.snps and mask.indiv have the same individuals
identical(rownames(geno.qc.snps), rownames(mask.indiv))
# returns false!
# This is the crucial filtering step for your genotype data.
# It ensures geno.qc has the same individuals as feno.qc.
geno.qc <- geno.qc.snps[mask.indiv, ]
# skipping to move on to next steps
geno.qc <- geno.qc.snps
feno.qc <- feno[mask.indiv, ]
identical(rownames(feno.qc), rownames(geno.qc))
dim(feno)
dim(feno.qc)
dim(geno)
dim(geno.qc)
# DISEASE_STATUS as factor with 3 levels
feno$DISEASE_STATUS <- factor(feno$DISEASE_STATUS,
levels=c("CN", "LMCI", "AD"))
# Binary Encoding (Case-Control)
feno$casecontrol <- ifelse(feno$DISEASE_STATUS == "AD", 1,
ifelse(feno$DISEASE_STATUS == "CN" | feno$DISEASE_STATUS == "LMCI", 0, NA))
# Association analysis
res <- snp.rhs.tests(casecontrol ~ AGE + REPORTED_SEX + YEARS_EDUCATION + APOE4 + PC1 + PC2, data=feno, snp.data=geno.qc,
family="binomial")
# list of top 5 SNPs
res[1:5,]
# Calculate ‘lambda’ and create a Q-Q plot to assess population stratification
chi2 <- chi.squared(res)
qq.chisq(chi2)
# create a manhattan plot
pvals <- data.frame(SNP=annotation$snp.name,
CHR=annotation$chromosome,
BP=annotation$position,
P=p.value(res))
# missing data is not allowed
pvals <- subset(pvals, !is.na(CHR) & !is.na(P))
plt <- manhattanPlot(pvals, color=c("gray90", "gray40"))
plt
# error:
# Error in base::nchar(wide_chars$test, type = "width") :
#   lazy-load database '/Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/cli/R/sysdata.rdb' is corrupt
# Extract p-values from res
p_values <- 1 - pchisq(res@chisq, df = res@df)  # Compute p-values
snps <- res@snp.names  # Extract SNP names
# create dataframe
gwas_results <- data.frame(
SNP = snps,
p_value = p_values
)
# Filter for significant SNPs (p < 1e-8) -- No SNPs passed this threshold
significant_snps <- subset(gwas_results, p_value < 1e-8)
# Filter for significant SNPs (p < 1e-5)
significant_snps <- subset(gwas_results, p_value < 1e-5)
# Print first few rows
#head(significant_snps)
# Add chromosome, position, allel.1, allel.2 columns from annotation to significant_snps, only selected columns.
significant_snps <- cbind(significant_snps, annotation[match(significant_snps$SNP, annotation$snp.name), c("chromosome", "position", "allele.1", "allele.2")])
# datatable, no row names
datatable(significant_snps, rownames = FALSE)
#--- Create a genetic score and assess its performance ---
# 1. Define your top SNPs found from the association analysis
# These are the 5 SNPs you identified in your report
top_snps <- c("rs10955311", "rs17793351", "rs11253696", "rs11857713", "rs4778636")
# 2. Convert the genotype data for these SNPs to a numeric matrix
# The 'as' function is perfect for converting a SnpMatrix object
snp_matrix_numeric <- as(geno.qc[, top_snps], "numeric")
# 3. Calculate the additive genetic score by summing the allele counts for each person
# rowSums sums across the columns (the SNPs) for each row (individual)
# na.rm = TRUE handles any missing genotypes gracefully
#feno.qc$genetic_score <- rowSums(snp_matrix_numeric, na.rm = TRUE)
# 4. Build the final logistic regression model to test the score's association with disease status
# Note: Ensure the `casecontrol` variable is present in feno.qc from your earlier binary encoding step.
# feno.qc$casecontrol <- ifelse(feno.qc$DISEASE_STATUS == "AD", 1, 0)
# This model includes the new score and all the required covariates
score_model <- glm(casecontrol ~ genetic_score + AGE + REPORTED_SEX + YEARS_EDUCATION + APOE4 + PC1 + PC2,
data = feno.qc,
family = "binomial")
# 5. Display the results
# The summary will show the Odds Ratio (after exponentiating the coefficient) and p-value for the genetic_score
summary(score_model)
# To get Odds Ratios and Confidence Intervals
# exp(coef(score_model))
# exp(confint(score_model))
#--- Create a genetic score and assess its performance ---
# 1. Define your top SNPs found from the association analysis
# These are the 5 SNPs you identified in your report
top_snps <- c("rs10955311", "rs17793351", "rs11253696", "rs11857713", "rs4778636")
# 2. Convert the genotype data for these SNPs to a numeric matrix
# The 'as' function is perfect for converting a SnpMatrix object
snp_matrix_numeric <- as(geno.qc[, top_snps], "numeric")
# 3. Calculate the additive genetic score by summing the allele counts for each person
# rowSums sums across the columns (the SNPs) for each row (individual)
# na.rm = TRUE handles any missing genotypes gracefully
#feno.qc$genetic_score <- rowSums(snp_matrix_numeric, na.rm = TRUE)
# 4. Build the final logistic regression model to test the score's association with disease status
# Note: Ensure the `casecontrol` variable is present in feno.qc from your earlier binary encoding step.
# feno.qc$casecontrol <- ifelse(feno.qc$DISEASE_STATUS == "AD", 1, 0)
# This model includes the new score and all the required covariates
score_model <- glm(casecontrol ~ genetic_score + AGE + REPORTED_SEX + YEARS_EDUCATION + APOE4 + PC1 + PC2,
data = feno.qc,
family = "binomial")
# 5. Display the results
# The summary will show the Odds Ratio (after exponentiating the coefficient) and p-value for the genetic_score
summary(score_model)
# To get Odds Ratios and Confidence Intervals
# exp(coef(score_model))
# exp(confint(score_model))
# 1. Define your top SNPs found from the association analysis
# These are the 5 SNPs you identified in your report
top_snps <- c("rs10955311", "rs17793351", "rs11253696", "rs11857713", "rs4778636")
# 2. Convert the genotype data for these SNPs to a numeric matrix
# The 'as' function is perfect for converting a SnpMatrix object
snp_matrix_numeric <- as(geno.qc[, top_snps], "numeric")
# 4. Build the final logistic regression model to test the score's association with disease status
# Note: Ensure the `casecontrol` variable is present in feno.qc from your earlier binary encoding step.
# feno.qc$casecontrol <- ifelse(feno.qc$DISEASE_STATUS == "AD", 1, 0)
# This model includes the new score and all the required covariates
score_model <- glm(casecontrol ~ genetic_score + AGE + REPORTED_SEX + YEARS_EDUCATION + APOE4 + PC1 + PC2,
data = feno.qc,
family = "binomial")
# 5. Display the results
# The summary will show the Odds Ratio (after exponentiating the coefficient) and p-value for the genetic_score
summary(score_model)
# To get Odds Ratios and Confidence Intervals
# exp(coef(score_model))
# exp(confint(score_model))
```
# 4. Build the final logistic regression model to test the score's association with disease status
# Note: Ensure the `casecontrol` variable is present in feno.qc from your earlier binary encoding step.
# feno.qc$casecontrol <- ifelse(feno.qc$DISEASE_STATUS == "AD", 1, 0)
# This model includes the new score and all the required covariates
score_model <- glm(casecontrol ~ genetic_score + AGE + REPORTED_SEX + YEARS_EDUCATION + APOE4 + PC1 + PC2,
data = feno.qc,
family = "binomial")
# 2. Convert the genotype data for these SNPs to a numeric matrix
# The 'as' function is perfect for converting a SnpMatrix object
snp_matrix_numeric <- as(geno.qc[, top_snps], "numeric")
# 3. Calculate the additive genetic score by summing the allele counts for each person
# rowSums sums across the columns (the SNPs) for each row (individual)
# na.rm = TRUE handles any missing genotypes gracefully
feno.qc$genetic_score <- rowSums(snp_matrix_numeric, na.rm = TRUE)
summary(info.indv$Call.rate > 0.9)
summary(abs(info.indv$hetF) < 0.15)
summary(!sex.discrep)
summary(abs(info.indv$hetF) < 0.02)
summary(abs(info.indv$hetF) < 0.2)
summary(info.indv$Call.rate > 0.9)
summary(abs(info.indv$hetF) < 0.2)
summary(!sex.discrep)
summary(!rownames(info.indv) %in% ids.rel)
# check if geno-qc.snps and mask.indiv have the same individuals
identical(rownames(geno.qc.snps), rownames(mask.indiv))
summary(abs(info.indv$hetF) < 0.3)
summary(!sex.discrep)
summary(!rownames(info.indv) %in% ids.rel)
# See the actual range of call rates for your individuals
summary(info.indv$Call.rate)
summary(info.indv$Call.rate > 0.85)
summary(abs(info.indv$hetF) < 0.3)
summary(!sex.discrep)
summary(!rownames(info.indv) %in% ids.rel)
## qc_indiv
use <- info.indv$Call.rate > 0.9 &
abs(info.indv$hetF) < 0.30 &     # or info.inv$Heterozygosity < 0.32
!sex.discrep &
!rownames(info.indv)%in%ids.rel
summary(info.indv$Call.rate > 0.9)
## qc_indiv
use <- info.indv$Call.rate > 0.85 &
abs(info.indv$hetF) < 0.30 &     # or info.inv$Heterozygosity < 0.32
!sex.discrep &
!rownames(info.indv)%in%ids.rel
mask.indiv <- use & !is.na(use)
summary(info.indv$Call.rate > 0.9)
summary(abs(info.indv$hetF) < 0.3)
summary(!sex.discrep)
summary(!rownames(info.indv) %in% ids.rel)
# IBD
# Transform PLINK data into GDS format
snpgdsBED2GDS("ADNI_cluster_01_forward_757LONI.bed", "ADNI_cluster_01_forward_757LONI.fam", "ADNI_cluster_01_forward_757LONI.bim",
out="GDS")
genofile <- snpgdsOpen("GDS")
#Prune SNPs for IBD analysis
set.seed(12345678)
snps.qc <- colnames(geno.qc.snps)
snp.prune <- snpgdsLDpruning(genofile, ld.threshold = 0.2,
snp.id = snps.qc)
snps.ibd <- unlist(snp.prune, use.names=FALSE)
head(snps.ibd)
# IBD analysis -- Identity By Descent
ibd <- snpgdsIBDMoM(genofile, kinship=TRUE,
snp.id = snps.ibd,
num.thread = 2)
ibd.kin <- snpgdsIBDSelection(ibd)
head(ibd.kin)
# Remove related individuals
ibd.kin.thres <- subset(ibd.kin, kinship > 0.1)
head(ibd.kin.thres)
## qc_related
ids.rel <-  SNPassoc:::related(ibd.kin.thres)
ids.rel
## qc_indiv
use <- info.indv$Call.rate > 0.85 &
abs(info.indv$hetF) < 0.30 &     # or info.inv$Heterozygosity < 0.32
!sex.discrep &
!rownames(info.indv)%in%ids.rel
mask.indiv <- use & !is.na(use)
summary(info.indv$Call.rate > 0.9)
summary(abs(info.indv$hetF) < 0.3)
summary(!sex.discrep)
summary(!rownames(info.indv) %in% ids.rel)
# > summary(!rownames(info.indv) %in% ids.rel)
#    Mode   FALSE    TRUE
# logical       3     754
# See the actual range of call rates for your individuals
summary(info.indv$Call.rate)
# check if geno-qc.snps and mask.indiv have the same individuals
identical(rownames(geno.qc.snps), rownames(mask.indiv))
# returns false!
# This is the crucial filtering step for your genotype data.
# It ensures geno.qc has the same individuals as feno.qc.
geno.qc <- geno.qc.snps[mask.indiv, ]
# skipping to move on to next steps
geno.qc <- geno.qc.snps
feno.qc <- feno[mask.indiv, ]
identical(rownames(feno.qc), rownames(geno.qc))
dim(feno)
dim(feno.qc)
dim(geno)
dim(geno.qc)
#--- Create a genetic score and assess its performance ---
# 1. Define your top SNPs found from the association analysis
# These are the 5 SNPs you identified in your report
top_snps <- c("rs10955311", "rs17793351", "rs11253696", "rs11857713", "rs4778636")
# 2. Convert the genotype data for these SNPs to a numeric matrix
# The 'as' function is perfect for converting a SnpMatrix object
snp_matrix_numeric <- as(geno.qc[, top_snps], "numeric")
# 3. Calculate the additive genetic score by summing the allele counts for each person
# rowSums sums across the columns (the SNPs) for each row (individual)
# na.rm = TRUE handles any missing genotypes gracefully
feno.qc$genetic_score <- rowSums(snp_matrix_numeric, na.rm = TRUE)
# IBD
# Transform PLINK data into GDS format
snpgdsBED2GDS("ADNI_cluster_01_forward_757LONI.bed", "ADNI_cluster_01_forward_757LONI.fam", "ADNI_cluster_01_forward_757LONI.bim",
out="GDS")
genofile <- snpgdsOpen("GDS")
#Prune SNPs for IBD analysis
set.seed(12345678)
snps.qc <- colnames(geno.qc.snps)
snp.prune <- snpgdsLDpruning(genofile, ld.threshold = 0.2,
snp.id = snps.qc)
snps.ibd <- unlist(snp.prune, use.names=FALSE)
head(snps.ibd)
# IBD analysis -- Identity By Descent
ibd <- snpgdsIBDMoM(genofile, kinship=TRUE,
snp.id = snps.ibd,
num.thread = 2)
ibd.kin <- snpgdsIBDSelection(ibd)
head(ibd.kin)
# Remove related individuals
ibd.kin.thres <- subset(ibd.kin, kinship > 0.1)
head(ibd.kin.thres)
## qc_related
ids.rel <-  SNPassoc:::related(ibd.kin.thres)
ids.rel
## qc_indiv
use <- info.indv$Call.rate > 0.85 &
abs(info.indv$hetF) < 0.30 &     # or info.inv$Heterozygosity < 0.32
!sex.discrep &
!rownames(info.indv)%in%ids.rel
mask.indiv <- use & !is.na(use)
summary(info.indv$Call.rate > 0.9)
summary(abs(info.indv$hetF) < 0.3)
summary(!sex.discrep)
summary(!rownames(info.indv) %in% ids.rel)
# > summary(!rownames(info.indv) %in% ids.rel)
#    Mode   FALSE    TRUE
# logical       3     754
# See the actual range of call rates for your individuals
summary(info.indv$Call.rate)
# check if geno-qc.snps and mask.indiv have the same individuals
identical(rownames(geno.qc.snps), rownames(mask.indiv))
# returns false!
# This is the crucial filtering step for your genotype data.
# It ensures geno.qc has the same individuals as feno.qc.
geno.qc <- geno.qc.snps[mask.indiv, ]
feno.qc <- feno[mask.indiv, ]
# skipping to move on to next steps
#geno.qc <- geno.qc.snps
identical(rownames(feno.qc), rownames(geno.qc))
dim(feno)
dim(feno.qc)
dim(geno)
dim(geno.qc)
#--- Create a genetic score and assess its performance ---
# 1. Define your top SNPs found from the association analysis
# These are the 5 SNPs you identified in your report
top_snps <- c("rs10955311", "rs17793351", "rs11253696", "rs11857713", "rs4778636")
# 2. Convert the genotype data for these SNPs to a numeric matrix
# The 'as' function is perfect for converting a SnpMatrix object
snp_matrix_numeric <- as(geno.qc[, top_snps], "numeric")
# 3. Calculate the additive genetic score by summing the allele counts for each person
# rowSums sums across the columns (the SNPs) for each row (individual)
# na.rm = TRUE handles any missing genotypes gracefully
feno.qc$genetic_score <- rowSums(snp_matrix_numeric, na.rm = TRUE)
# 4. Build the final logistic regression model to test the score's association with disease status
# Note: Ensure the `casecontrol` variable is present in feno.qc from your earlier binary encoding step.
# feno.qc$casecontrol <- ifelse(feno.qc$DISEASE_STATUS == "AD", 1, 0)
# This model includes the new score and all the required covariates
score_model <- glm(casecontrol ~ genetic_score + AGE + REPORTED_SEX + YEARS_EDUCATION + APOE4 + PC1 + PC2,
data = feno.qc,
family = "binomial")
# 5. Display the results
# The summary will show the Odds Ratio (after exponentiating the coefficient) and p-value for the genetic_score
summary(score_model)
# To get Odds Ratios and Confidence Intervals
# exp(coef(score_model))
# exp(confint(score_model))
# Extract p-values from res
p_values <- 1 - pchisq(res@chisq, df = res@df)  # Compute p-values
snps <- res@snp.names  # Extract SNP names
# create dataframe
gwas_results <- data.frame(
SNP = snps,
p_value = p_values
)
# Filter for significant SNPs (p < 1e-8) -- No SNPs passed this threshold
significant_snps <- subset(gwas_results, p_value < 1e-8)
# Filter for significant SNPs (p < 1e-5)
significant_snps <- subset(gwas_results, p_value < 1e-5)
# Print first few rows
#head(significant_snps)
# Add chromosome, position, allel.1, allel.2 columns from annotation to significant_snps, only selected columns.
significant_snps <- cbind(significant_snps, annotation[match(significant_snps$SNP, annotation$snp.name), c("chromosome", "position", "allele.1", "allele.2")])
# datatable, no row names
datatable(significant_snps, rownames = FALSE)
#--- Create a genetic score and assess its performance ---
# 1. Define your top SNPs found from the association analysis
# These are the 5 SNPs you identified in your report
top_snps <- c("rs10955311", "rs17793351", "rs11253696", "rs11857713", "rs4778636")
# 2. Convert the genotype data for these SNPs to a numeric matrix
# The 'as' function is perfect for converting a SnpMatrix object
snp_matrix_numeric <- as(geno.qc[, top_snps], "numeric")
# 3. Calculate the additive genetic score by summing the allele counts for each person
# rowSums sums across the columns (the SNPs) for each row (individual)
# na.rm = TRUE handles any missing genotypes gracefully
feno.qc$casecontrol <- ifelse(feno.qc$DISEASE_STATUS == "AD", 1, 0)
# 4. Build the final logistic regression model to test the score's association with disease status
# Note: Ensure the `casecontrol` variable is present in feno.qc from your earlier binary encoding step.
# feno.qc$casecontrol <- ifelse(feno.qc$DISEASE_STATUS == "AD", 1, 0)
# This model includes the new score and all the required covariates
score_model <- glm(casecontrol ~ genetic_score + AGE + REPORTED_SEX + YEARS_EDUCATION + APOE4 + PC1 + PC2,
data = feno.qc,
family = "binomial")
# 5. Display the results
# The summary will show the Odds Ratio (after exponentiating the coefficient) and p-value for the genetic_score
summary(score_model)
# To get Odds Ratios and Confidence Intervals
# exp(coef(score_model))
# exp(confint(score_model))
#--- Create a genetic score and assess its performance ---
# 1. Define your top SNPs found from the association analysis
# These are the 5 SNPs you identified in your report
top_snps <- c("rs10955311", "rs17793351", "rs11253696", "rs11857713", "rs4778636")
# 2. Convert the genotype data for these SNPs to a numeric matrix
# The 'as' function is perfect for converting a SnpMatrix object
snp_matrix_numeric <- as(geno.qc[, top_snps], "numeric")
# 3. Calculate the additive genetic score by summing the allele counts for each person
# rowSums sums across the columns (the SNPs) for each row (individual)
# na.rm = TRUE handles any missing genotypes gracefully
feno.qc$casecontrol <- ifelse(feno.qc$DISEASE_STATUS == "AD", 1, 0)
feno.qc$genetic_score <- rowSums(snp_matrix_numeric, na.rm = TRUE)
# 4. Build the final logistic regression model to test the score's association with disease status
# Note: Ensure the `casecontrol` variable is present in feno.qc from your earlier binary encoding step.
# feno.qc$casecontrol <- ifelse(feno.qc$DISEASE_STATUS == "AD", 1, 0)
# This model includes the new score and all the required covariates
score_model <- glm(casecontrol ~ genetic_score + AGE + REPORTED_SEX + YEARS_EDUCATION + APOE4 + PC1 + PC2,
data = feno.qc,
family = "binomial")
# 5. Display the results
# The summary will show the Odds Ratio (after exponentiating the coefficient) and p-value for the genetic_score
summary(score_model)
# To get Odds Ratios and Confidence Intervals
# exp(coef(score_model))
# exp(confint(score_model))
# 1. Define your top SNPs found from the association analysis
# These are the 5 SNPs you identified in your report
top_snps <- c("rs10955311", "rs17793351", "rs11253696", "rs11857713", "rs4778636")
# 2. Convert the genotype data for these SNPs to a numeric matrix
# The 'as' function is perfect for converting a SnpMatrix object
snp_matrix_numeric <- as(geno.qc[, top_snps], "numeric")
# 3. Calculate the additive genetic score by summing the allele counts for each person
# rowSums sums across the columns (the SNPs) for each row (individual)
# na.rm = TRUE handles any missing genotypes gracefully
feno.qc$casecontrol <- ifelse(feno.qc$DISEASE_STATUS == "AD", 1, 0)
feno.qc$genetic_score <- rowSums(snp_matrix_numeric, na.rm = TRUE)
# 4. Build the final logistic regression model to test the score's association with disease status
# Note: Ensure the `casecontrol` variable is present in feno.qc from your earlier binary encoding step.
# feno.qc$casecontrol <- ifelse(feno.qc$DISEASE_STATUS == "AD", 1, 0)
# This model includes the new score and all the required covariates
score_model <- glm(casecontrol ~ genetic_score + AGE + REPORTED_SEX + YEARS_EDUCATION + APOE4 + PC1 + PC2,
data = feno.qc,
family = "binomial")
# 5. Display the results
# The summary will show the Odds Ratio (after exponentiating the coefficient) and p-value for the genetic_score
summary(score_model)
# To get Odds Ratios and Confidence Intervals
# exp(coef(score_model))
# exp(confint(score_model))
```
# 5. Display the results
# The summary will show the Odds Ratio (after exponentiating the coefficient) and p-value for the genetic_score
summary(score_model)
quit()
