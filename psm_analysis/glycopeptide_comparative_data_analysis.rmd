---
title: "Comparative Glycoproteomics Analysis"
author: "Richard Shipman"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true
    latex_engine: xelatex # Often provides better character support
params:
  psm_files: ["psm_withEndoE.tsv", "psm_withoutEndoE.tsv"]
  protein_name: "VP8_SA11"
  signal_peptide_length: 19
---

```{r setup, include=FALSE}
# Load necessary libraries
# Ensure you have these installed: install.packages(c("tidyverse", "here", "viridis", "RColorBrewer", "ggrepel", "DT", "VennDiagram"))
library(tidyverse)
library(here)
library(viridis)
library(RColorBrewer)
library(ggrepel)
library(DT)
library(VennDiagram)
library(grid)

# Set a consistent theme for all plots
theme_set(theme_minimal(base_size = 12) +
            theme(strip.background = element_rect(fill = "gray90", color = "gray50"),
                  strip.text = element_text(face = "bold"),
                  plot.title = element_text(face = "bold", hjust = 0.5, size = 16),
                  legend.position = "bottom"))
```

### 1. Introduction

This report details a site-specific, comparative analysis of glycopeptide data from mass spectrometry experiments. The analysis was performed on `psm.tsv` files generated by the FragPipe MSFragger-Glyco workflow. 

The primary protein of interest is **`r params$protein_name`**. The goal is to compare glycosylation patterns across multiple experimental conditions, as defined by the input files.

**Parameters for this analysis:**

* **Protein of Interest:** `r params$protein_name`
* **Signal Peptide Length (to subtract):** `r params$signal_peptide_length`
* **Input Files:** `r paste(params$psm_files, collapse = ", ")`

---

### 2. Data Loading and Preprocessing

The `psm.tsv` files were loaded and combined. The data was then filtered for the protein of interest. **Crucially, to correctly identify unoccupied sites, PSMs are grouped by their peptide backbone. Glycosite information is propagated from glycosylated peptides to their non-glycosylated counterparts. Only then are peptides lacking glycan information correctly labeled as "Unoccupied".**

```{r load-and-preprocess, message=FALSE, warning=FALSE}
# Function to load and preprocess a single PSM file
load_and_prep_psm <- function(file_path) {
  read_tsv(file_path, show_col_types = FALSE) %>%
    # Use the filename (without extension) as the sample name
    mutate(sample = tools::file_path_sans_ext(basename(file_path))) %>%
    # Select the relevant columns, ensuring 'sample' and 'Peptide' are retained
    select(sample, Peptide, Protein, `Best Positions`, `Protein Start`, `Total Glycan Composition`) %>%
    # Rename columns for easier use
    rename_with(~str_replace_all(., " ", "_") %>% tolower())
}

# Load all files and combine them
all_psms_raw <- map_dfr(params$psm_files, load_and_prep_psm)

# Process the combined data
gpsm_data <- all_psms_raw %>%
  # Filter for the target protein
  filter(protein == params$protein_name) %>%
  # Calculate initial glycosite position (will be NA for non-glyco peptides)
  mutate(
    glycosite = as.numeric(str_extract(best_positions, "\\d+")) + protein_start - params$signal_peptide_length
  ) %>%
  # *** FIX: Correctly identify Unoccupied peptides ***
  # Group by the peptide backbone to find non-glycosylated versions of glycopeptides
  group_by(peptide, sample) %>%
  # Propagate the glycosite information from the glycosylated PSM to the non-glycosylated one
  fill(glycosite, .direction = "downup") %>%
  ungroup() %>%
  # Now that glycosites are filled, filter out any peptides that are never associated with a site
  filter(!is.na(glycosite)) %>%
  # Now, we can safely label the remaining NAs as Unoccupied
  mutate(total_glycan_composition = replace_na(total_glycan_composition, "Unoccupied % 0.0")) %>%
  # Extract glycan composition and mass
  mutate(
    glycan = str_trim(str_extract(total_glycan_composition, ".*(?=%)")),
    glycan_mass = as.numeric(str_extract(total_glycan_composition, "(?<=%)[\\d\\.]+"))
  ) %>%
  # Handle cases where mass extraction fails or is zero for unoccupied
  mutate(glycan_mass = if_else(is.na(glycan_mass) | glycan == "Unoccupied", 0.0, glycan_mass))

cat("Data loaded and preprocessed.\n")
cat("Total PSMs for", params$protein_name, ":", nrow(gpsm_data), "\n")
```

Glycoforms are defined as unique combinations of glycan structures at specific glycosites. The `total_glycan_composition` column contains the glycan structure and its mass, which is used to identify and categorize glycoforms.

Glycoform subcategories are defined based on the monosaccharide composition of the glycan structures. The categorization is done using a set of rules that classify glycans into broader categories (e.g., High Mannose, Hybrid, Complex) and specific subcategories (e.g., M5, M6, E, H).

---

### 3. Glycoform Categorization

Each identified glycan was classified into a broader category and a more specific subcategory based on its monosaccharide composition. This allows for both high-level and detailed comparisons of glycan types.

```{r categorize-glycans}
# Function to categorize glycoforms and subcategories based on composition string
categorize_glycoform <- function(glycan_str) {
  
  # Helper to extract counts, returns 0 if pattern not found
  get_count <- function(pattern) {
    match <- str_match(glycan_str, pattern)
    if (is.na(match[1, 2])) 0 else as.numeric(match[1, 2])
  }

  hexnac <- get_count("HexNAc\\((\\d+)\\)")
  h_hex  <- get_count("Hex\\((\\d+)\\)")
  fuc    <- get_count("Fuc\\((\\d+)\\)") + get_count("dHex\\((\\d+)\\)") # Combine Fuc and dHex
  neuac  <- get_count("NeuAc\\((\\d+)\\)")

  # Apply categorization rules
  category <- case_when(
    str_detect(glycan_str, "Unoccupied") ~ "Unoccupied",
    hexnac == 1 & h_hex == 0 & neuac == 0 ~ "EndoE Truncated",
    hexnac == 2 & h_hex >= 5 ~ "High Mannose",
    hexnac == 2 & h_hex >= 2 & h_hex < 5 & fuc == 0 ~ "Hybrid",
    hexnac == 2 & h_hex >= 2 & h_hex < 5 & fuc >= 1 ~ "Hybrid (Fucosylated)",
    (hexnac >= 3 & h_hex >= 2) | (hexnac >= 2 & h_hex >= 3) | neuac >= 1 ~ "Complex",
    TRUE ~ "Other" # Default case
  )
  
  # Apply subcategory rules
  subcategory <- case_when(
    category == "Unoccupied" ~ "UO",
    category == "EndoE Truncated" & fuc == 0 ~ "E",
    category == "EndoE Truncated" & fuc == 1 ~ "E F1",
    category == "High Mannose" & h_hex == 5 ~ "M5",
    category == "High Mannose" & h_hex == 6 ~ "M6",
    category == "High Mannose" & h_hex == 7 ~ "M7",
    category == "High Mannose" & h_hex == 8 ~ "M8",
    category == "High Mannose" & h_hex == 9 ~ "M9",
    category == "High Mannose" & h_hex == 10 ~ "M10",
    category == "Hybrid" ~ "H",
    category == "Hybrid (Fucosylated)" ~ "FH",
    category == "Other" ~ "O",
    TRUE ~ NA_character_
  )
  
  return(tibble(glycoform_category = category, glycoform_subcategory = subcategory))
}

# Apply the categorization to the data
gpsm_data <- gpsm_data %>%
  mutate(purrr::map_df(total_glycan_composition, categorize_glycoform))

# Define a consistent order for categories for all plots
category_order <- c('Unoccupied', 'EndoE Truncated', 'Hybrid', 'Hybrid (Fucosylated)', 
                    'High Mannose', 
                    'Complex', 'Other')

# Define a consistent order for subcategories
subcategory_order <- c('UO', 'E', 'E F1', 'H', 'FH',
                       'M5', 'M6', 'M7', 'M8', 'M9', 'M10', 'O')


# Filter the order to only include categories present in the data
category_order_filtered <- intersect(category_order, unique(gpsm_data$glycoform_category))

# Create a consistent color map using a new palette
num_colors <- length(category_order_filtered)
color_palette <- brewer.pal(max(3, num_colors), name = "Spectral") 
category_colors <- setNames(color_palette[1:num_colors], category_order_filtered)


# Display a summary table of category counts
gpsm_data %>%
  # Convert to factor with the specified level order
  mutate(glycoform_category = factor(glycoform_category, levels = category_order)) %>%
  # Count the occurrences
  count(sample, glycoform_category, .drop = FALSE) %>%
  # Pivot to wide format
  pivot_wider(names_from = sample, values_from = n, values_fill = 0) %>%
  # Arrange the final table according to the specified order
  arrange(glycoform_category) %>%
  knitr::kable(caption = "PSM Counts per Glycoform Category")
```

---

### 4. Comparative Analysis of Glycosite Occupancy and Diversity

#### Occupancy Heatmaps

The following heatmaps show the percentage of glycoforms at each site for each sample. This provides a high-level overview of glycan diversity and site occupancy. Darker colors indicate higher relative abundance. **The grid now shows all categories and sites, even those with 0% abundance, for consistent comparison.**

```{r plot-heatmaps, fig.width=10, fig.height=7}
# Calculate percentage for heatmaps and other plots
plot_data <- gpsm_data %>%
  count(sample, glycosite, glycoform_category, glycoform_subcategory, name = "psm_count") %>%
  group_by(sample, glycosite) %>%
  mutate(percentage = psm_count / sum(psm_count) * 100) %>%
  ungroup()

# Get all unique sites across all samples to ensure they are all plotted
all_sites_in_data <- sort(unique(gpsm_data$glycosite))

# Generate a heatmap for each sample
for (s in unique(plot_data$sample)) {
  
  # Aggregate data for the main category heatmap
  heatmap_cat_data <- plot_data %>%
    filter(sample == s) %>%
    group_by(sample, glycosite, glycoform_category) %>%
    summarise(percentage = sum(percentage), .groups = 'drop') %>%
    ungroup() %>%
    tidyr::complete(glycosite = all_sites_in_data, 
                    glycoform_category = category_order_filtered, 
                    fill = list(percentage = 0, sample = s))
  
  p <- heatmap_cat_data %>%
    ggplot(aes(x = glycoform_category, y = as.factor(glycosite), fill = percentage)) +
    geom_tile(color = "gray80") +
    geom_text(data = . %>% filter(percentage > 0), aes(label = round(percentage, 1)), color = "black", size = 3) +
    scale_fill_distiller(palette = "Spectral", name = "Percentage (%)", limits = c(0, 100)) +
    # Use limits to enforce order and presence of all categories/sites
    scale_x_discrete(limits = category_order_filtered, drop = FALSE, guide = guide_axis(angle = 45)) +
    scale_y_discrete(limits = rev(as.character(all_sites_in_data)), drop = FALSE) +
    labs(
      title = paste("Glycoform Occupancy for Sample:", s),
      x = "Glycoform Category",
      y = "Glycosite"
    )
  
  print(p)
}
```

#### Comparative Pie Charts per Site

To compare the relative abundance of glycoform categories more directly, the following plots show a pie chart for each sample at each glycosite. Labels are placed to avoid overlap for better readability.

```{r plot-pie-charts, fig.width=12, fig.height=15}
# Aggregate data for pie charts
pie_plot_data <- plot_data %>%
  group_by(sample, glycosite, glycoform_category) %>%
  summarise(percentage = sum(percentage), .groups = 'drop') %>%
  filter(percentage > 1)

ggplot(pie_plot_data, aes(x = 1, y = percentage, fill = glycoform_category)) +
  geom_col(width = 1, color = "white") +
  geom_text(aes(label = paste0(round(percentage), "%")), 
            position = position_stack(vjust = 0.5),
            color = "black", 
            size = 3.5, 
            fontface = "bold") +
  coord_polar("y", start = 0) +
  facet_grid(glycosite ~ sample, labeller = labeller(glycosite = 
      function(x) paste("Site", x))) +
  scale_fill_manual(values = category_colors, name = "Glycoform Category") +
  labs(
    title = "Comparative Glycoform Distribution at Each Site"
  ) +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5, size = 16),
    strip.text = element_text(face = "bold"),
    legend.position = "bottom"
  )
```

#### Venn Diagram of Unique Glycopeptides

The Venn diagram below illustrates the overlap of unique glycopeptides between the two sample conditions. A glycopeptide is defined as a unique combination of a peptide backbone and its attached glycan. This helps to visualize the number of shared and condition-specific glycopeptides.

```{r plot-venn-diagram, message=FALSE, warning=FALSE, fig.height=6, fig.width=8}
# Create a unique identifier for each glycopeptide (peptide + glycan)
# We filter out "Unoccupied" as it does not represent a glycopeptide.
venn_data <- gpsm_data %>%
  filter(glycoform_category != "Unoccupied") %>%
  mutate(glycopeptide_id = paste(peptide, glycan, sep = "_"))

# Get unique glycopeptides for the 'withEndoE' sample
with_endo_e_peptides <- venn_data %>%
  filter(sample == "psm_withEndoE") %>%
  distinct(glycopeptide_id) %>%
  pull(glycopeptide_id)

# Get unique glycopeptides for the 'withoutEndo' sample
without_endo_peptides <- venn_data %>%
  filter(sample == "psm_withoutEndo") %>%
  distinct(glycopeptide_id) %>%
  pull(glycopeptide_id)

# Create a list for the Venn diagram function
# The names of the list elements will be the labels on the diagram
venn_list <- list(
  `With EndoE` = with_endo_e_peptides,
  `Without EndoE` = without_endo_peptides
)

# Disable the log file generation that VennDiagram creates by default
futile.logger::flog.threshold(futile.logger::ERROR, name = "VennDiagramLogger")

# Generate the Venn diagram. The plot is drawn directly to the output device.
grid.newpage()
venn.plot <- venn.diagram(
  x = venn_list,
  filename = NULL, # This ensures it plots to the R device instead of a file
  output = TRUE,
  imagetype = "png",
  # Main title
  main = "Comparison of Unique Glycopeptides",
  main.cex = 1.5,
  main.fontface = "bold",
  # Circles
  lwd = 2,
  lty = 'blank',
  fill = c("#66C2A5", "#FC8D62"), # FIX: Provide a vector of 2 colors
  # Numbers inside circles
  cex = 1.5,
  fontface = "bold",
  # Set names (Category names)
  cat.cex = 1.2,
  cat.fontface = "bold",
  cat.default.pos = "outer",
  cat.dist = c(0.055, 0.055),
  cat.pos = c(-20, 20)
)
grid.draw(venn.plot)
```

---

### 5. Site-Specific Microheterogeneity Analysis

The following plots provide a more detailed, site-by-site view of the specific glycan structures and categories identified, allowing for a deep dive into the microheterogeneity at each location.

#### Category-Level PSM Counts

This plot shows the absolute number of PSMs for each glycoform **category** at each site. This is useful for comparing raw counts rather than percentages. The bars are set to a fixed width for easier comparison across facets.

```{r plot-category-counts, fig.width=12, fig.height=8}
# Aggregate data to the category level
category_plot_data <- plot_data %>%
  group_by(sample, glycosite, glycoform_category) %>%
  summarise(psm_count = sum(psm_count), .groups = 'drop') %>%
  ungroup() %>%
  # Ensure all categories and samples are present for correct bar alignment
  tidyr::complete(nesting(glycosite, glycoform_category), sample, fill = list(psm_count = 0))


ggplot(category_plot_data, aes(x = glycoform_category, y = psm_count, fill = sample)) +
  # Use position_dodge(preserve = "total") to keep bar widths consistent
  geom_col(position = position_dodge(preserve = "total"), color = "black", linewidth = 0.5) +
  facet_wrap(~glycosite, ncol = 3, scales = "free_y", labeller = labeller(glycosite = 
      function(x) paste("Site", x))) +
  scale_fill_brewer(palette = "Spectral", name = "Sample") +
  # Enforce the new category order on the x-axis
  scale_x_discrete(limits = category_order) +
  labs(
    title = "Comparative PSM Counts per Category at Each Site",
    x = "Glycoform Category",
    y = "Total PSM Count"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


#### Subcategory-Level PSM Counts

This plot shows the absolute number of PSMs for each glycoform **subcategory** at each site. This is useful for comparing the abundance of specific glycan structures (e.g., M5 vs. M9). The bars are set to a fixed width for easier comparison across facets.

```{r plot-subcategory-counts, fig.width=12, fig.height=8}
# Data is already prepared in 'plot_data'
subcategory_plot_data <- plot_data %>%
  filter(!is.na(glycoform_subcategory)) %>%
  ungroup() %>%
  # Ensure all subcategories and samples are present for correct bar alignment
  tidyr::complete(nesting(glycosite, glycoform_subcategory), sample, fill = list(psm_count = 0))

if(nrow(subcategory_plot_data) > 0) {
  ggplot(subcategory_plot_data, aes(x = glycoform_subcategory, y = psm_count, fill = sample)) +
    # Use position_dodge(preserve = "total") to keep bar widths consistent
    geom_col(position = position_dodge(preserve = "total"), color = "black", linewidth = 0.5) +
    facet_wrap(~glycosite, ncol = 3, scales = "free_y", labeller = labeller(glycosite = 
        function(x) paste("Site", x))) +
    scale_fill_brewer(palette = "Spectral", name = "Sample") +
    # Enforce the new subcategory order on the x-axis
    scale_x_discrete(limits = subcategory_order) +
    labs(
      title = "Comparative PSM Counts per Subcategory at Each Site",
      x = "Glycoform Subcategory",
      y = "Total PSM Count"
    ) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
} else {
  cat("No subcategory data available to plot.")
}
```



---

### 6. Conclusion

This report provides a comprehensive, comparative analysis of glycopeptide data. The visualizations highlight key differences in site occupancy, glycoform diversity, and specific glycan abundance between the analyzed samples.


---

### Appendix: Processed PSM Data Table

The following table contains the relevant processed data for all PSMs used in this analysis. You can search, sort, and filter the table to explore the data.

```{r data-table, echo=FALSE}
# Select the most relevant columns for the final table
summary_table_data <- gpsm_data %>%
  select(Sample = sample, 
         Peptide = peptide,
         Glycosite = glycosite, 
         `Total Glycan Composition` = total_glycan_composition, 
         `Glycoform Category` = glycoform_category,
         `Glycoform Subcategory` = glycoform_subcategory) %>%
  arrange(Glycosite)

# Create data table
knitr::kable(summary_table_data,
             caption = "Summary of Processed PSMs",
             booktabs = TRUE)

# Write results to CSV
write_csv(summary_table_data, "processed_psm_data.csv")
```