#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Glycopeptide PSM Data Analysis Script (Updated)

This script performs a site-specific glycoform analysis on the psm.tsv file 
generated by the FragPipe MSFragger-Glyco workflow. It identifies glycosites,
analyzes glycan composition and glycoform distribution, and generates
summary statistics and plots.

This updated version includes:
- Consistent coloring across all plots.
- Separation of N- and O-glycan data into separate CSV files.
- Addition of error bars to site-specific bar plots.
- Enhanced plot aesthetics with bold titles and outlines.
- Export of glycosite occupancy data to a CSV file.
- Code updated to address library warnings for future compatibility.
- A more detailed glycoform categorization logic.
- A restored series of plots showing glycan composition for each site individually.
- Formatted site occupancy data to two decimal places.
- Refined pie chart labels and bolded percentage values.

Usage:
    python glycopeptide_psm_data_analysis.py -i <path_to_psm.tsv> -p <protein_name> -s <signal_peptide_length>
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import re
import argparse
import os
from pathlib import Path
from matplotlib.ticker import MaxNLocator

# --- Function Definitions ---

def load_data(file_path):
    """
    Loads the PSM data from a tab-separated file.

    Args:
        file_path (str): The path to the psm.tsv file.

    Returns:
        pandas.DataFrame: A DataFrame containing the PSM data, or None if file not found.
    """
    try:
        df = pd.read_csv(file_path, sep='\t')
        print(f"Successfully loaded {file_path}")
        print(f"A total of {len(df)} PSMs were found in the data.")
        return df
    except FileNotFoundError:
        print(f"--- ERROR ---")
        print(f"The file was not found at the specified path: '{file_path}'")
        return None

def preprocess_data(df, signal_peptide_length):
    """
    Preprocesses the raw PSM DataFrame.

    This function cleans column names, calculates glycosite positions,
    and fills in missing glycosite information.

    Args:
        df (pandas.DataFrame): The input DataFrame.
        signal_peptide_length (int): The length of the signal peptide to subtract.

    Returns:
        pandas.DataFrame: The preprocessed DataFrame.
    """
    # Standardize column names
    df.columns = df.columns.str.replace('.', '_', regex=False).str.replace(' ', '_').str.lower()
    
    # Fill missing total_glycan_composition values
    if 'total_glycan_composition' in df.columns:
        df['total_glycan_composition'] = df['total_glycan_composition'].fillna('Unoccupied % 0.0')
    else:
        df['total_glycan_composition'] = 'Unoccupied % 0.0'
        
    # Calculate initial glycosite position
    df['glycosite'] = df['best_positions'].str.extract(r'(\d+)').astype(float)
    df['glycosite'] = df['glycosite'] + df['protein_start'] - signal_peptide_length

    # Fill missing glycosites for peptides within the same group
    # Updated to address DeprecationWarning by using include_groups=False
    df = df.groupby('peptide').apply(fill_missing_glycosites, include_groups=False)
    # Corrected reset_index to preserve the 'peptide' column
    df = df.reset_index()
    
    print("Preprocessing complete. Glycosites computed and mapped.")
    return df
    
def fill_missing_glycosites(group):
    """
    Helper function to fill NaN glycosite values within a peptide group.
    """
    existing_glycosites = group['glycosite'].dropna().unique()
    if existing_glycosites.size > 0:
        group['glycosite'] = group['glycosite'].fillna(existing_glycosites[0])
    return group

def categorize_glycoforms(glycan_str):
    """
    Categorizes a glycan string into a Glycoform Category and Subcategory
    based on parsed monosaccharide composition.
    """
    category = "Other"
    subcategory = None

    # Find the number inside HexNAc(number)
    hexnac_match = re.search(r'HexNAc\((\d+)\)', glycan_str)
    # Find the number inside Hex(number)
    hex_match = re.search(r'Hex\((\d+)\)', glycan_str)
    # Find the number inside Fuc(number)
    fuc_match = re.search(r'Fuc\((\d+)\)', glycan_str)
    # Find the number inside NeuAc(number)
    neuac_match = re.search(r'NeuAc\((\d+)\)', glycan_str)
    # Find the number inside dHex(number) - often Fuc
    dhex_match = re.search(r'dHex\((\d+)\)', glycan_str)
    # Find the number inside Pent(number)
    pent_match = re.search(r'Pent\((\d+)\)', glycan_str)
    # Find the number inside Sulf(number)
    sulf_match = re.search(r'Sulf\((\d+)\)', glycan_str)
    # Find the number inside Phosphate(number)
    phosphate_match = re.search(r'Phosphate\((\d+)\)', glycan_str)

    hexnac = int(hexnac_match.group(1)) if hexnac_match else 0
    h_hex = int(hex_match.group(1)) if hex_match else 0
    fuc = int(fuc_match.group(1)) if fuc_match else 0
    neuac = int(neuac_match.group(1)) if neuac_match else 0
    dhex = int(dhex_match.group(1)) if dhex_match else 0
    pent = int(pent_match.group(1)) if pent_match else 0
    sulf = int(sulf_match.group(1)) if sulf_match else 0
    phosphate = int(phosphate_match.group(1)) if phosphate_match else 0

    fuc = fuc + dhex 

    # --- Categorization Logic based on Monosaccharide Counts ---
    if "Unoccupied" in glycan_str:
        category = "Unoccupied"
    elif hexnac == 1 and h_hex == 0 and neuac == 0 and pent == 0 and sulf == 0 and phosphate == 0:
        if fuc in [0, 1, 2]:
             category = "EndoE"
    elif hexnac == 2 and h_hex >= 5 and fuc == 0 and neuac == 0 and pent == 0 and sulf == 0 and phosphate == 0:
        category = "Oligomannose"
    elif hexnac == 2 and h_hex >= 5 and fuc >= 1 and neuac == 0 and pent == 0 and sulf == 0 and phosphate == 0:
        category = "Oligomannose (Fucosylated)"
    elif hexnac == 2 and h_hex >= 2 and h_hex < 5 and fuc == 0:
        category = "Hybrid"
    elif hexnac == 2 and h_hex >= 2 and h_hex < 5 and fuc >= 1:
         category = "Hybrid (Fucosylated)"
    elif (hexnac >= 3 and h_hex >= 2) or (hexnac >= 2 and h_hex >= 3) or neuac >= 1:
        category = "Complex"
    elif (hexnac == 0 and h_hex == 1 and fuc == 0 and neuac == 0 and pent == 0 and sulf == 0 and phosphate == 0) or \
         (hexnac == 1 and h_hex == 1 and fuc == 0 and neuac == 0 and pent == 0 and sulf == 0 and phosphate == 0):
        category = "O-Glycan"

    # --- Subcategory Logic ---
    if category == "O-Glycan":
        subcategory = "O"
    elif category == "Unoccupied":
         subcategory = "UO"
    elif category == "EndoE":
        if fuc == 0: subcategory = "E"
        elif fuc == 1: subcategory = "E F1"
        elif fuc == 2: subcategory = "E F2"
    elif category == "Oligomannose":
        if h_hex == 10: subcategory = "M10"
        elif h_hex == 9: subcategory = "M9"
        elif h_hex == 8: subcategory = "M8"
        elif h_hex == 7: subcategory = "M7"
        elif h_hex == 6: subcategory = "M6"
        elif h_hex == 5: subcategory = "M5"
    elif category == "Hybrid":
         subcategory = "H"
    elif category == "Hybrid (Fucosylated)":
         subcategory = "FH"

    return pd.Series([category, subcategory])


def generate_summary_files(n_glycan_psms, o_glycan_psms, output_dir, file_prefix):
    """
    Generates and saves summary files for N- and O-glycans.
    """
    # --- N-Glycan Summary ---
    if not n_glycan_psms.empty:
        n_csv_path = os.path.join(output_dir, f"{file_prefix}_N-Glycan_PSMs.csv")
        n_glycan_psms.to_csv(n_csv_path, index=False)
        print(f"N-glycan PSM data saved to: {n_csv_path}")

        stats_file_path = os.path.join(output_dir, f"{file_prefix}_N-Glycan_summary_stats.txt")
        unique_glycosites = sorted(n_glycan_psms['glycosite'].dropna().unique())
        with open(stats_file_path, 'w') as f:
            f.write(f"--- N-Glycopeptide Analysis Summary ---\n")
            f.write(f"Total N-GlycoPSMs for Target Protein: {len(n_glycan_psms)}\n")
            f.write(f"Identified N-Glycosites: {', '.join([str(int(s)) for s in unique_glycosites])}\n\n")
            f.write("--- N-Glycoform Category Counts ---\n")
            category_counts = n_glycan_psms['glycoform_category'].value_counts()
            f.write(category_counts.to_string())
        print(f"N-glycan summary stats saved to: {stats_file_path}")

    # --- O-Glycan Summary ---
    if not o_glycan_psms.empty:
        o_csv_path = os.path.join(output_dir, f"{file_prefix}_O-Glycan_PSMs.csv")
        o_glycan_psms.to_csv(o_csv_path, index=False)
        print(f"O-glycan PSM data saved to: {o_csv_path}")
        
        o_stats_file_path = os.path.join(output_dir, f"{file_prefix}_O-Glycan_summary_stats.txt")
        unique_o_glycosites = sorted(o_glycan_psms['glycosite'].dropna().unique())
        with open(o_stats_file_path, 'w') as f:
            f.write(f"--- O-Glycopeptide Analysis Summary ---\n")
            f.write(f"Total O-GlycoPSMs for Target Protein: {len(o_glycan_psms)}\n")
            f.write(f"Identified O-Glycosites: {', '.join([str(int(s)) for s in unique_o_glycosites])}\n\n")
            f.write("--- O-Glycoform Composition Counts ---\n")
            composition_counts = o_glycan_psms['total_glycan_composition'].value_counts()
            f.write(composition_counts.to_string())
        print(f"O-glycan summary stats saved to: {o_stats_file_path}")


def plot_glycan_coverage(df, output_dir, file_prefix, category_order, color_map):
    """
    Creates a stacked bar chart showing glycan type coverage per site
    and saves the underlying data to a CSV file.
    """
    coverage_data = df.groupby(['glycosite', 'glycoform_category']).size().unstack(fill_value=0)
    ordered_cols = [cat for cat in category_order if cat in coverage_data.columns]
    coverage_data = coverage_data[ordered_cols]
    
    coverage_data_percent = coverage_data.div(coverage_data.sum(axis=1), axis=0) * 100
    
    # --- Round data to two decimal places ---
    coverage_data_percent = coverage_data_percent.round(2)
    
    # --- Save glycosite occupancy data to CSV ---
    occupancy_csv_path = os.path.join(output_dir, f"{file_prefix}_glycosite_occupancy_summary.csv")
    coverage_data_percent.to_csv(occupancy_csv_path)
    print(f"Glycosite occupancy data saved to: {occupancy_csv_path}")
    
    ax = coverage_data_percent.plot(kind='bar', stacked=True, 
                                    color=[color_map.get(cat, '#808080') for cat in ordered_cols], 
                                    figsize=(14, 8),
                                    edgecolor='black', linewidth=1)
    
    plt.title(f'Glycan Type Coverage per Site for {file_prefix}', fontweight='bold')
    plt.xlabel('Glycosite')
    plt.ylabel('Percentage (%)')
    plt.xticks(rotation=0)
    plt.legend(title='Glycoform Category', bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.tight_layout()
    plot_path = os.path.join(output_dir, f"{file_prefix}_glycan_site_coverage.png")
    plt.savefig(plot_path)
    plt.close()
    print(f"Glycan coverage plot saved to: {plot_path}")

def plot_site_pie_charts(df, sites, output_dir, file_prefix, category_order, color_map):
    """
    Generates a pie chart of glycoform distribution for each glycosite
    with consistent coloring and outlines.
    """
    for site in sites:
        site_data = df[df['glycosite'] == site]
        category_counts = site_data['glycoform_category'].value_counts()
        
        if not category_counts.empty:
            ordered_labels = [cat for cat in category_order if cat in category_counts.index]
            category_counts = category_counts.reindex(ordered_labels).dropna()
            
            # This lambda function formats the percentage string to be bold using LaTeX formatting.
            bold_formatter = lambda pct: r'$\bf{%.1f\%%}$' % pct
            
            pie_colors = [color_map.get(label, '#808080') for label in category_counts.index]
            
            plt.figure(figsize=(10, 8))
            plt.pie(category_counts, labels=category_counts.index,
                    autopct=bold_formatter,
                    startangle=90, 
                    colors=pie_colors,
                    wedgeprops={'edgecolor': 'black', 'linewidth': 1},
                    pctdistance=0.8,
                    labeldistance=1.1,
                    textprops={'fontsize': 'medium'})
            
            plt.title(f'Glycoform Distribution at Site {int(site)}', fontweight='bold')
            plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
            
            plot_path = os.path.join(output_dir, f"{file_prefix}_pie_site_{int(site)}.png")
            plt.savefig(plot_path, bbox_inches='tight')
            plt.close()
            print(f"Pie chart for site {int(site)} saved to: {plot_path}")

def plot_total_glycan_composition(df, output_dir, file_prefix):
    """
    Plots the total PSM count for each glycan composition across all sites, ordered by mass.
    """
    plot_data = df.groupby(['total_glycan_composition', 'glycan_mass'])['psm_count'].sum().reset_index()
    plot_data = plot_data.sort_values('glycan_mass')

    plt.figure(figsize=(16, 9))
    # Updated barplot call to address FutureWarning
    ax = sns.barplot(data=plot_data, x='total_glycan_composition', y='psm_count', palette='viridis', hue='total_glycan_composition', dodge=False, legend=False)
    # Updated tick rotation method to avoid UserWarning
    plt.xticks(rotation=45, ha='right')
    
    plt.title(f'Total PSM Count for Glycan Compositions of {file_prefix} Across All Sites', fontweight='bold')
    plt.xlabel('Total Glycan Composition (Ordered by Mass)')
    plt.ylabel('PSM Count')
    plt.tight_layout()
    plot_path = os.path.join(output_dir, f"{file_prefix}_total_glycan_composition.png")
    plt.savefig(plot_path)
    plt.close()
    print(f"Total glycan composition plot saved to: {plot_path}")


def plot_glycosite_categories_with_errorbars(df, sites, category_order, color_map, output_dir, file_prefix, protein_name):
    """
    Plots the Glycoform Category PSM counts for each specific glycosite with error bars.
    """
    # This dummy column is used to calculate counts and standard deviation in seaborn
    df_plot = df.copy()
    df_plot['psm_for_counting'] = 1

    for site in sites:
        site_data = df_plot[df_plot['glycosite'] == site]
        
        plt.figure(figsize=(12, 7))
        # Updated barplot call to address FutureWarning
        ax = sns.barplot(
            x='glycoform_category', 
            y='psm_for_counting', 
            data=site_data, 
            palette=color_map, 
            order=category_order,
            hue='glycoform_category',
            legend=False,
            estimator=sum, 
            #errorbar='sd',  # Add standard deviation error bars
            capsize=0.1,
            edgecolor='black', # Add bar outlines
            linewidth=1.5
        )
        ax.yaxis.set_major_locator(MaxNLocator(integer=True))
        
        plt.title(f"Glycoform Category PSM Count at Glycosite {int(site)} for {protein_name}", fontweight='bold')
        plt.xlabel("Glycoform Category")
        plt.ylabel("Total PSM Count")
        plt.xticks(rotation=45, ha='right')
        plt.tight_layout()
        
        plot_path = os.path.join(output_dir, f"{file_prefix}_categories_site_{int(site)}.png")
        plt.savefig(plot_path)
        plt.close()
        print(f"Category plot with error bars for site {int(site)} saved to: {plot_path}")

def plot_glycan_composition_per_site(df_summary, sites, color_map, output_dir, file_prefix, protein_name):
    """
    Generates a bar plot of glycan composition PSM count for each glycosite,
    colored by glycoform category.
    """
    # Create a dataframe of all unique glycans and their properties from the main summary
    all_glycans_df = df_summary[['total_glycan_composition', 'glycan_mass', 'glycoform_category']].drop_duplicates()

    for site in sites:
        # Get data for the specific site
        site_data = df_summary[df_summary['glycosite'] == site].copy()
        
        # Merge with all glycans to include those with zero counts for this site
        plot_data = pd.merge(
            all_glycans_df, 
            site_data[['total_glycan_composition', 'glycan_mass', 'psm_count']], 
            on=['total_glycan_composition', 'glycan_mass'], 
            how='left'
        )
        
        plot_data['psm_count'] = plot_data['psm_count'].fillna(0).astype(int)
        plot_data = plot_data.sort_values('glycan_mass')
        plot_data = plot_data[plot_data['total_glycan_composition'] != 'Unoccupied % 0.0']

        if plot_data.empty:
            print(f"Skipping composition plot for site {int(site)} as there is no data to show.")
            continue

        plt.figure(figsize=(16, 9))
        ax = sns.barplot(
            data=plot_data, 
            x='total_glycan_composition', 
            y='psm_count', 
            palette=color_map, 
            hue='glycoform_category', 
            dodge=False,
            edgecolor='black',
            linewidth=1
        )
        
        ax.yaxis.set_major_locator(MaxNLocator(integer=True))
        plt.xticks(rotation=45, ha='right')

        plt.title(f'Glycan Composition PSM Count at Glycosite {int(site)} for {protein_name}', fontweight='bold')
        plt.xlabel('Glycan Composition (Ordered by Mass)')
        plt.ylabel('PSM Count')
        
        handles, labels = ax.get_legend_handles_labels()
        unique_labels = dict(zip(labels, handles))
        ax.legend(unique_labels.values(), unique_labels.keys(), title='Glycoform Category', bbox_to_anchor=(1.05, 1), loc='upper left')

        plt.tight_layout()
        plot_path = os.path.join(output_dir, f"{file_prefix}_composition_site_{int(site)}.png")
        plt.savefig(plot_path)
        plt.close()
        print(f"Composition plot for site {int(site)} saved to: {plot_path}")


# --- Main Execution ---

def main():
    """
    Main function to run the glycopeptide analysis workflow.
    """
    parser = argparse.ArgumentParser(description="Glycopeptide PSM Data Analysis Script")
    parser.add_argument("-i", "--input", required=True, help="Path to the psm.tsv file.")
    parser.add_argument("-p", "--protein", required=True, help="Name of the target protein (from 'Protein' column).")
    parser.add_argument("-s", "--signal", type=int, default=0, help="Length of the signal peptide to be subtracted (default: 0).")
    
    args = parser.parse_args()
    
    file_prefix = Path(args.input).stem
    output_dir = f"{file_prefix}_analysis_results"
    os.makedirs(output_dir, exist_ok=True)

    df = load_data(args.input)
    if df is None: return

    df_processed = preprocess_data(df, args.signal)

    gpsm = df_processed[df_processed['protein'] == args.protein].copy()
    if gpsm.empty:
        print(f"No PSMs found for the target protein: {args.protein}")
        return
        
    gpsm.dropna(subset=['glycosite'], inplace=True)
    gpsm['glycan'] = gpsm['total_glycan_composition'].apply(lambda x: x.split('%')[0].strip())
    
    try:
        gpsm['glycan_mass'] = gpsm['total_glycan_composition'].str.extract(r'%\s*([\d.]+)').astype(float)
    except Exception as e:
        print(f"Warning: Could not extract all glycan masses due to an error: {e}.")
        if 'glycan_mass' not in gpsm.columns:
            gpsm['glycan_mass'] = np.nan

    gpsm.loc[gpsm['glycan'] == 'Unoccupied', 'glycan_mass'] = 0.0
    gpsm['glycan_mass'] = gpsm['glycan_mass'].fillna(value=0.0)
    
    gpsm[['glycoform_category', 'glycoform_subcategory']] = gpsm['total_glycan_composition'].apply(categorize_glycoforms)
    print("Successfully categorized glycoforms based on composition.")

    custom_category_order = ['O-Glycan', 'Unoccupied', 'EndoE', 'Hybrid', 'Hybrid (Fucosylated)', 'Oligomannose', 'Oligomannose (Fucosylated)', 'Complex', 'Other']
    
    # --- Separate N-glycans and O-glycans ---
    n_glycan_psms = gpsm[gpsm['glycoform_category'] != 'O-Glycan'].copy()
    o_glycan_psms = gpsm[gpsm['glycoform_category'] == 'O-Glycan'].copy()

    # --- Create category order and color map specifically for N-glycan plots ---
    n_all_categories = n_glycan_psms['glycoform_category'].unique()
    n_category_order = [cat for cat in custom_category_order if cat in n_all_categories]
    
    palette = sns.color_palette('viridis', len(n_category_order))
    color_map = dict(zip(n_category_order, palette))
    
    # Create summary dataframes for counting
    n_gpsm_summary = n_glycan_psms.groupby([
        'peptide', 'glycosite', 'total_glycan_composition', 'glycan', 'glycan_mass', 
        'glycoform_category', 'glycoform_subcategory'
    ]).size().reset_index(name='psm_count')
    
    o_gpsm_summary = o_glycan_psms.groupby([
        'peptide', 'glycosite', 'total_glycan_composition', 'glycan', 'glycan_mass', 
        'glycoform_category', 'glycoform_subcategory'
    ]).size().reset_index(name='psm_count')
    
    # --- Generate summary CSV and TXT files for N- and O-glycans ---
    generate_summary_files(n_glycan_psms, o_glycan_psms, output_dir, file_prefix)
    
    print("\n--- Generating Plots for N-Glycans (including EndoE, excluding O-Glycans) ---")
    if not n_glycan_psms.empty:
        unique_n_glycosites = sorted(n_glycan_psms['glycosite'].dropna().unique())
        
        plot_glycan_coverage(n_glycan_psms, output_dir, file_prefix, n_category_order, color_map)
        plot_site_pie_charts(n_glycan_psms, unique_n_glycosites, output_dir, file_prefix, n_category_order, color_map)
        plot_total_glycan_composition(n_gpsm_summary, output_dir, file_prefix)
        plot_glycosite_categories_with_errorbars(n_glycan_psms, unique_n_glycosites, n_category_order, color_map, output_dir, file_prefix, args.protein)
        
        # --- Plot glycan composition per site ---
        plot_glycan_composition_per_site(n_gpsm_summary, unique_n_glycosites, color_map, output_dir, file_prefix, args.protein)

    else:
        print("Skipping N-glycan plots as no N-glycan PSMs were found.")

    print("\nAnalysis complete.")

if __name__ == '__main__':
    main()
